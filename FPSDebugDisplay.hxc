import funkin.util.Constants;
import funkin.Preferences;
import funkin.modding.module.Module;
import funkin.ui.options.OptionsState;
import funkin.ui.title.TitleState;
import funkin.save.Save;
import flixel.FlxG;
import flixel.math.FlxMath;
import funkin.ui.FullScreenScaleMode;
import funkin.modding.ModStore;
import Main;
import String; // lol?

class FPSDebugDisplay extends Module
{
  public static final OFF:String = 'Off';
  public static final SIMPLE:String = 'Simple';
  public static final ADVANCED:String = 'Advanced';

  function new()
  {
    super('FPSDebugDisplay', -0x7FFFFFFF);
    
    // KoloInDaKrue
    // Force debug display to appear
    FlxG.signals.postGameStart.add(() -> {
        modPreference = modPreference;
        repositionCounters(false);
    });
    
    // We hijack the built-in positioning function with our own
    if (!ModStore.register("FPS_Hijacked", false))
    {
        // hopefully no other mods do the same...
        FlxG.signals.preUpdate.removeAll();
        
        FlxG.signals.preUpdate.add(() -> repositionCounters(true));
        
        repositionCounters(false);
    }
  }

  public var modPreference(get, set):String;

  function get_modPreference():String
  {
    if (Save.instance.modOptions.exists("FPSDisplayMobile"))
    {
      var debugMode:Null<Any> = Save.instance.modOptions["FPSDisplayMobile"];
      // Migration shit. The value is now stored as a string since 0.8.0
      if (!(debugMode is String))
      {
        debugMode = modPreference = switch (debugMode)
        {
          case 0: OFF;
          case 1: SIMPLE;
          case 2: ADVANCED;
          default: OFF;
        };
      }
      // get this shit away from here
      Save.instance.modOptions.remove("FPSDisplayMobile");
      
      return debugMode;
    }

    // Getting it from preferences always returns OFF, so we bypass that by getting it directly from the save data.
    return Save.instance.options?.debugDisplay ?? OFF;
  }

  function set_modPreference(value:String):String
  {
    Save.instance.options.debugDisplay = value;
    Save.instance.flush();
    Preferences.setDebugDisplayMode(value);
    return value;
  }
  
  var ignoreNotch(get, set):Bool;
  
  function get_ignoreNotch():Bool
  {
    return Save.instance.modOptions["FPS_ignoreNotchMinecraft"] ?? false;
  }
  
  function set_ignoreNotch(v):Bool
  {
    Save.instance.modOptions["FPS_ignoreNotchMinecraft"] = v;
    Save.instance.flush();
    return v;
  }

  public override function onStateChangeEnd(event:StateChangeScriptEvent)
  {
    if (!Constants.DEBUG_BUILD && !FlxG.onMobile) return;
    

    if (event.targetState is OptionsState)
    {
      var prefsMenu:PreferencesMenu = event.targetState.optionsCodex.pages.get('preferences');
      prefsMenu.createPrefItemEnum('Debug Display', 'When enabled, FPS and other debug stats are displayed.',
        ["Advanced" => ADVANCED, "Simple" => SIMPLE, "Off" => OFF], (key, value) -> {
          // getting debugDisplay always results in Off but we set it so that it also updates the display
          Preferences.debugDisplay = modPreference = value;
        }, modPreference);

      prefsMenu.createPrefItemPercentage('Debug Display BG', "Adjust the debug display's background opacity.", function(value:Int):Void {
        Preferences.debugDisplayBGOpacity = value;
      }, Preferences.debugDisplayBGOpacity);
      
      prefsMenu.createPrefItemCheckbox("Ignore Notch Size", "Whether the display's positioning ignores the screen notch size. Enable this if the position is too far from the corner.",
        (value) -> {
            ignoreNotch = value;
        }, ignoreNotch);
    }
  }
  
  function repositionCounters(lerp:Bool):Void
  {
    // Calling this so it gets scaled based on the resolution of the game and device's resolution.
    var scale:Float = Math.min(FlxG.stage.stageWidth / FlxG.width, FlxG.stage.stageHeight / FlxG.height);

    if (FlxG.android != null) // aint you a clever betch
        scale = Math.max(scale, 1);
    else
        scale = Math.min(scale, 1);
        
    final notchSizeX = ignoreNotch ? 0 : FullScreenScaleMode.notchSize.x;
    final thypos:Float = Math.max(notchSizeX, 50);

    var debugDisplay = Main.debugDisplay;
    if (debugDisplay != null)
    {
      debugDisplay.scaleX = debugDisplay.scaleY = scale;

      if (FlxG.game != null)
      {
        if (lerp)
        {
          debugDisplay.x = FlxMath.lerp(debugDisplay.x, FlxG.game.x + thypos, FlxG.elapsed * 3);
        }
        else
        {
          debugDisplay.x = FlxG.game.x + notchSizeX + 10;
        }

        debugDisplay.y = FlxG.game.y + (3 * scale);
      }
    }
  }
}